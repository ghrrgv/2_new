# если таблица истинности частично заполнена
from itertools import *
def f(x, y, z, w):
    return (not(x)) and ((z<=y)<=w)

for a in product([0, 1], repeat=4):
    table = [(0, a[0], 1, a[1]), (1, a[2], 0, 1), (0, 0, a[3],1)] # из таблицы
    if len(set(table)) != 3: continue #потому что в условии сказано что таблица не содержит одинаковых строк, set = считает только уникальные строки
    for i in permutations('xyzw'):
        if [f(**dict(zip(i, stroka)))for stroka in table] == [1, 1, 0]:
            print(i)

# 1. создаём функцию с логическим выражением
# 2. product - функция которая создаёт все возможные упорядоченные пары элементов. Для каждого неизвестного элемента в таблице истинности
# задаём а с индексом, так мы получим все возможные вариации таблицы истинности
# 3. благодаря permutations создаём все возможные комбинации xyzw
# 4. проходимся по каждому эелементу списка table, которое соеденяем
# с i расположением столбцов (x,y,z,w/y,w,z,x/z,x,y,w и т.д.) благораря функции zip()
# потом из этого создаётся словарик и с помощью функции f (** - распоковка словаря)
# сравниваем что получилось в трёх логических выражениях и какими они должны быть (в этом случае это [1,1,0]
# выводим подходящую комбинацию x, y, z, w